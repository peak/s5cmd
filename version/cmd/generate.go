// This package will generate version/version.go by running git commands to get current branch and commit hash
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
)

func cmdOutput(cmd string, arg ...string) string {
	var buf bytes.Buffer

	c := exec.Command(cmd)
	c.Args = append(c.Args, arg...)
	c.Stdout = &buf
	c.Stderr = os.Stderr
	err := c.Run()

	if err != nil {
		log.Fatal(err)
		return ""
	}

	return strings.Trim(buf.String(), "\n\r ")
}

const destinationFile = "version/version.go"

func main() {
	gitTag := cmdOutput("git", strings.Split("describe --tags --abbrev=0", " ")...)
	gitCommit := cmdOutput("git", strings.Split("rev-parse HEAD", " ")...)
	gitCommit = gitCommit[:6]

	var buf bytes.Buffer
	fmt.Fprint(&buf, "// Package version is auto-generated using version/cmd/generate.go on non-release builds.\n")
	fmt.Fprint(&buf, "package version\n\n")
	fmt.Fprint(&buf, "// Code generated by version/cmd/generate.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "import %q\n", "strings")
	fmt.Fprintln(&buf, "")
	fmt.Fprintf(&buf, "const Version = %q\n", gitTag)
	fmt.Fprintf(&buf, "const GitCommit = %q\n", gitCommit)
	fmt.Fprint(&buf, `
func GetHumanVersion() string {
	version := Version
	if !strings.HasPrefix(version, "v") {
		version = "v" + Version
	}

	return Version + "-" + GitCommit
}
`)

	log.Printf("Writing %s...\n", destinationFile)
	if err := ioutil.WriteFile(destinationFile, buf.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}
