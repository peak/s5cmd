// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"
import io "io"
import mock "github.com/stretchr/testify/mock"
import objurl "github.com/peak/s5cmd/objurl"
import storage "github.com/peak/s5cmd/storage"

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
	mock.Mock
}

// Copy provides a mock function with given fields: ctx, src, dst, metadata
func (_m *Storage) Copy(ctx context.Context, src *objurl.ObjectURL, dst *objurl.ObjectURL, metadata map[string]string) error {
	ret := _m.Called(ctx, src, dst, metadata)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *objurl.ObjectURL, *objurl.ObjectURL, map[string]string) error); ok {
		r0 = rf(ctx, src, dst, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, src
func (_m *Storage) Delete(ctx context.Context, src *objurl.ObjectURL) error {
	ret := _m.Called(ctx, src)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *objurl.ObjectURL) error); ok {
		r0 = rf(ctx, src)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, src, dst
func (_m *Storage) Get(ctx context.Context, src *objurl.ObjectURL, dst io.WriterAt) (int64, error) {
	ret := _m.Called(ctx, src, dst)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, *objurl.ObjectURL, io.WriterAt) int64); ok {
		r0 = rf(ctx, src, dst)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *objurl.ObjectURL, io.WriterAt) error); ok {
		r1 = rf(ctx, src, dst)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, src, recursive
func (_m *Storage) List(ctx context.Context, src *objurl.ObjectURL, recursive bool) <-chan *storage.Object {
	ret := _m.Called(ctx, src, recursive)

	var r0 <-chan *storage.Object
	if rf, ok := ret.Get(0).(func(context.Context, *objurl.ObjectURL, bool) <-chan *storage.Object); ok {
		r0 = rf(ctx, src, recursive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *storage.Object)
		}
	}

	return r0
}

// ListBuckets provides a mock function with given fields: ctx, prefix
func (_m *Storage) ListBuckets(ctx context.Context, prefix string) ([]storage.Bucket, error) {
	ret := _m.Called(ctx, prefix)

	var r0 []storage.Bucket
	if rf, ok := ret.Get(0).(func(context.Context, string) []storage.Bucket); ok {
		r0 = rf(ctx, prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, prefix)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MakeBucket provides a mock function with given fields: ctx, bucket
func (_m *Storage) MakeBucket(ctx context.Context, bucket string) error {
	ret := _m.Called(ctx, bucket)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MultiDelete provides a mock function with given fields: ctx, urls
func (_m *Storage) MultiDelete(ctx context.Context, urls <-chan *objurl.ObjectURL) <-chan *storage.Object {
	ret := _m.Called(ctx, urls)

	var r0 <-chan *storage.Object
	if rf, ok := ret.Get(0).(func(context.Context, <-chan *objurl.ObjectURL) <-chan *storage.Object); ok {
		r0 = rf(ctx, urls)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *storage.Object)
		}
	}

	return r0
}

// Put provides a mock function with given fields: ctx, src, dst, metadata
func (_m *Storage) Put(ctx context.Context, src io.Reader, dst *objurl.ObjectURL, metadata map[string]string) error {
	ret := _m.Called(ctx, src, dst, metadata)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader, *objurl.ObjectURL, map[string]string) error); ok {
		r0 = rf(ctx, src, dst, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stat provides a mock function with given fields: ctx, src
func (_m *Storage) Stat(ctx context.Context, src *objurl.ObjectURL) (*storage.Object, error) {
	ret := _m.Called(ctx, src)

	var r0 *storage.Object
	if rf, ok := ret.Get(0).(func(context.Context, *objurl.ObjectURL) *storage.Object); ok {
		r0 = rf(ctx, src)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.Object)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *objurl.ObjectURL) error); ok {
		r1 = rf(ctx, src)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
